<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F15%2F%E7%BD%97%E7%B4%A0-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%80%8C%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[title: ‘罗素:我为什么而活’copyright: truedate: 2018-11-15 13:44:21tags: [励志, 鸡汤] categories: 励志中文译文对爱情的渴望，对知识的追求，对人类苦难不可遏制的同情心，这三种纯洁而无比强烈的激情支配着我的一生。这三种激情，就像飓风一样，在深深的苦海上，肆意地把我吹来吹去，吹到濒临绝望的边缘。 我寻求爱情，首先因为爱情给我带来狂喜，它如此强烈以致我经常愿意为了几小时的欢愉而牺牲生命中的其他一切。我寻求爱情，其次是因为爱情可以解除孤寂一—那是一颗震颤的心，在世界的边缘，俯瞰那冰冷死寂、深不可测的深渊。我寻求爱情，最后是因为在爱情的结合中，我看到圣徒和诗人们所想像的天堂景象的神秘缩影。这就是我所寻求的，虽然它对人生似乎过于美好，然而最终我还是得到了它。 我以同样的热情寻求知识，我渴望了解人的心灵。我渴望知道星星为什么闪闪发光，我试图理解毕达哥拉斯的思想威力，即数字支配着万物流转。这方面我获得一些成就，然而并不多。 爱情和知识，尽其可能地把我引上天堂，但是同情心总把我带回尘世。痛苦的呼唤经常在我心中回荡，饥饿的儿童，被压迫被折磨者，被儿女视为负担的无助的老人以及充满孤寂、贫穷和痛苦的整个世界，都是对人类应有生活的嘲讽。我渴望减轻这些不幸，但是我无能为力，而且我自己也深受其害。 这就是我的一生，我觉得值得为它活着。如果有机会的话，我还乐意再活一次。 英文原文《What I Have Lived For》 by Bertrand Russell Three passions, simple but overwhelmingly strong, have governed my life: the longing for love, the search for knowledge, and unbearable pity for the suffering of mankind. These passions, like great winds, have blown me hither and thither, in a wayward course, over a great ocean of anguish, reaching to the very verge of despair. I have sought love, first, because it brings ecstasy - ecstasy so great that I would often have sacrificed all the rest of life for a few hours of this joy. I have sought it, next, because it relieves loneliness–that terrible loneliness in which one shivering consciousness looks over the rim of the world into the cold unfathomable lifeless abyss. I have sought it finally, because in the union of love I have seen, in a mystic miniature, the prefiguring vision of the heaven that saints and poets have imagined. This is what I sought, and though it might seem too good for human life, this is what–at last–I have found. With equal passion I have sought knowledge. I have wished to understand the hearts of men. I have wished to know why the stars shine. And I have tried to apprehend the Pythagorean power by which number holds sway above the flux. A little of this, but not much, I have achieved. Love and knowledge, so far as they were possible, led upward toward the heavens. But always pity brought me back to earth. Echoes of cries of pain reverberate in my heart. Children in famine, victims tortured by oppressors, helpless old people a burden to their sons, and the whole world of loneliness, poverty, and pain make a mockery of what human life should be. I long to alleviate this evil, but I cannot, and I too suffer. This has been my life. I have found it worth living, and would gladly live it again if the chance were offered me.]]></content>
  </entry>
  <entry>
    <title><![CDATA[李开复:追随我心]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%9D%8E%E5%BC%80%E5%A4%8D-%E8%BF%BD%E9%9A%8F%E6%88%91%E5%BF%83%2F</url>
    <content type="text"><![CDATA[并不很久的以前,也就在1979年到1980年间,在哥伦比亚大学,两个政治科学系大一的新生,在课堂上总是没精打采。其中一个是来自台湾的华裔,喜欢窝在教室左后方的一隅,听得无趣,索性呼呼大睡。这个男孩叫李开复,此君并非厌学,而是对政治科学越来越不感兴趣。蹉跎到大二下学期,他终于决定快刀斩乱麻——转系,改学自己感兴趣的计算机。 兴趣是什么?兴趣就意味着天赋。李开复在计算机系如鱼得水,左右逢源,两年后毕业,成绩居全系之首。这样的学生用不着按部就班。在教授的推荐下,李开复进入在计算机领域独领风骚的卡内基•梅隆大学,直接攻读博士。计算机学院的院长找他谈话,劈头就问:“读博士的目的是什么?”李开复大声答:“我从大学带走的将是一篇改变世界的、顶尖的博士论文。”院长予以纠正,说:“你从这儿带走的最有价值的东西,不是一篇论文,而是你分析、思考的能力,研究、发现真理的经验,以及科学家的胸怀。这样,当你有一天改变研究方向,依然可以在任何一个新的领域出类拔萃。”李开复选定语音识别为攻读方向,经过一年“热恋”,他发现专家系统其冷如冰,远不如统计学有情有义。李开复决心“移情别恋”。他担心导师发怒,谁知得到的回答竟是:“开复,你对专家系统和统计的观点,我是不赞同的,但我可以支持你用统计的方法去做,因为我相信科学没有绝对的对错,我们都是平等的。而且,我更相信一个富有激情的人可以找到更好的解决方案。”李开复从导师的大度悟到科学的真谛,他全力以赴,放手一搏。3年过去了,李开复的研究成果及博士论文,引发了那年语音世界最大的冲击波。26岁的李开复功成名就,成为卡内基•梅隆大学最年轻的副教授。天之骄子,有尊严,有地位,有课题,有经费,出任大公司顾问,飞赴各地讲学,包括去他的祖籍之邦、魂之所系的祖国大陆。 “让世界因你而不同!”这是李开复埋在心底多年的梦想。1990年,苹果公司的一个邀请电话让李开复开始审视自己:“开复,你是想一辈子写一堆像废纸一样的学术论文,还是想真正地改变世界?”面对苹果公司的召唤,李开复旋即做出回应,走出象牙塔,加盟“改变世界”的大军。在苹果公司,李开复感受到了从纸上谈兵转入实战的无穷乐趣。1995年,33岁的李开复出任苹果公司的副总裁。 但是他仍然不满足,依然要跳槽,因为硅谷的另一家公司SGI发出了更有诱惑力的邀请——“你想做什么,然后我们根据你的兴趣对公司进行改组。”不是他们缺什么人才,让你去填补,而是诚恳地询问你需要什么平台,以便为你量身搭建。这样的机遇,李开复岂能错过!双方一拍即合, 1996年7月,李开复跳槽去了SGI。李开复奉行“自己设计自己”的人生信条,怎奈SGI是一家硬件公司,开复的长处却在软件开发,这就等于在篮球场上跑马,任是赤兔、骅骝,也撒不开四蹄。日复一日,李开复萌生去意。对于下一个选择,他立下两条标准:一是做软件,二是去中国。 机会来了。其实机会无处不在,就看你有没有做好准备。彼时,比尔•盖茨创立的微软王国要把触角伸向中国,李开复成为它的不二人选。时间:1998年金秋;职务:微软中国研究院院长。李开复在中国市场的开拓,值得写部书来描述,那是一种完全不同的创新理念、绝对领先的科学技术在神州大地生根发芽。微软只是起用了一个人,就开拓了中国市场;李开复只是“追随我心”,就一跃成为微软王国的副总裁。在你我想来,这该是李开复的最后一站。在微软占据高位,与比尔•盖茨亲密共事,坐拥财富和风光,“花迎喜气皆知笑,鸟识欢心亦解歌”。人生至此,夫复何求?李开复不这么想,他后来回忆:“我如同一部庞大机器上的零件,在中规中矩、没有任何发挥空间的环境下运行着。这是一个随时随地都可以被替换的光鲜零件。那种价值的缺失感以及精神上的落寞占据了我的内心。”微软既然已无成长空间,那就走吧!到哪儿去?他相中了Google。但他清醒地意识到,管理更多的人马,不是自己的所爱,他渴望从无到有的创新,而不是经营一个巨无霸。于是,在2009年9月,李开复又一次选择潇洒地离去。向总部递交辞呈之际,Google高管艾伦•尤斯塔斯试图用更优厚的条件予以挽留。李开复真诚地说:“我的人生还有一个缺憾没有实现,现在得去弥补。我可能创办一家‘创新工场’,和中国青年一起创造新的技术奇迹。” 如今,李开复正在按照他本人的意愿,在神州大地进行“创新工场”试验。他会成功吗?我想这是毫无疑问的,也是次要又次要的,那么,最主要的一点是什么呢?诚如他自己所言:“人生在世时间非常短,如果你总是不敢做想做的事情,那么一生过去了,你留下来的只有悔恨,只有懊恼。”“我步入丛林,因为我希望生活得有意义,我希望活得深刻,并汲取生命中所有的精华,然后从中学习,以免让我在生命终结时,才发现自己从来没有活过。”]]></content>
      <categories>
        <category>励志</category>
      </categories>
      <tags>
        <tag>励志</tag>
        <tag>励志故事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python自动下载图虫网图库]]></title>
    <url>%2F2018%2F11%2F14%2Fpython%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%9B%BE%E8%99%AB%E7%BD%91%E5%9B%BE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[如何使用下载工程源码点击下载或者git bash;git clone git@github.com:inspurer/PythonSpider.git 下载相关依赖在命令行下依此输入 pip install requests pip install pyquery 打开图虫网选择你喜欢的图库链接,比如https://tuchong.com/4293835/23849565/复制并替换到tuchong_gallery.py代码里面的gallery_url,解释一下这个链接的作用,前一个数字串是作者的id,后一个数字串是作者该图库的id注意,在打开这个图库时,复制地址前最好不要左右浏览 运行tuchong_gallery.py你就可以看到在下载这个图库的图片了图库保存在工程目录下,文件夹名为作者和图库的id每一张图片保存在该文件夹下,格式为:imageid.jpg 计划更新增加自动搜索]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序json.parse错误]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%B0%8F%E7%A8%8B%E5%BA%8Fjson-parse%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[错误详情今天查看上线的微信小程序后台，发现了一个这样的错误: Unexpected token in JSON at position 52; at pages/send/send onShow function; at api request success callback function 于是我打开调试工具查看源代码并且调试:VM792:1 thirdScriptError Unexpected token in JSON at position 52;at pages/send/send onShow function; at api request success callback function SyntaxError: Unexpected token in JSON at position 52 at JSON.parse (&lt;anonymous&gt;) at success (http://127.0.0.1:60162/appservice/pages/send/send.js:130:35) at http://127.0.0.1:60162/appservice/utils/bmob.js:2293:37 at wrappedResolvedCallback (http://127.0.0.1:60162/appservice/utils/bmob.js:2219:48) at http://127.0.0.1:60162/appservice/utils/bmob.js:2171:34 at Object._.each._.forEach [as _arrayEach] (http://127.0.0.1:60162/appservice/utils/underscore.js:161:17) at Bmob.Promise.resolve (http://127.0.0.1:60162/appservice/utils/bmob.js:2170:18) at wrappedResolvedCallback (http://127.0.0.1:60162/appservice/utils/bmob.js:2228:37) at http://127.0.0.1:60162/appservice/utils/bmob.js:2171:34 at Object._.each._.forEach [as _arrayEach] (http://127.0.0.1:60162/appservice/utils/underscore.js:161:17) 果不其然,小程序已然上线,这个错误一定不能忍 调试过程通过错误信息定位到出错的代码通过上面的报错信息：at success (http://127.0.0.1:60162/appservice/pages/send/send.js:130:35)定位到出错的代码是在130行:var jsonB = JSON.parse(jsonA); 上网浏览查询相关资料网上的说法不一而足,实在不知道该听信哪家之言不过都集中在json文件不能有注释、json字符串url有误、json字符串有特殊字符 定位原因排除了几种错误后还没有解决问题，有点心灰意冷,尝试着输出json字符串中的每一个字符 51 &quot;。&quot; 52 &quot; &quot; 53 &quot;2&quot; 等等,换行符确是是个特殊字符(ps,在js里面\r是回车符,\n是换行符,)(在小程序中,我这个jsonA是包含用户的键盘输入信息的) 解决办法jsonA = jsonA.replace(&apos;\n&apos;,&apos;&apos;) 后话小程序的预览可以查看: 点击查看小程序的所有源代码: github地址]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【持续更新】hexo next主题优化手册]]></title>
    <url>%2F2018%2F11%2F11%2Fhexo-next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言开此贴的原因前几天博客崩了，重新搭建了这个博客站点。特开此贴记录next主题优化过程中遇到的问题，希望对大家有所帮助。 一些说明前期相关的Hexo安装、本地/远程部署教程可百度在此不再赘述。基于hexo-next v5.1.4,向上兼容,向下兼容性不确定，特此声明。我的博客本地根目录是D:\hexoblog站点配置文件全路径是‪D:\hexoblog\_config.ymlnext主题文件全路径是‪D:\hexoblog\themes\next\_config.yml hexo常见操作hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo clean #清除部署緩存hexo n == hexo new #新建文章hexo g == hexo generate #生成静态页面至public目录hexo s == hexo server #开启预览访问端口（默认端口4000，可在浏览器输入localhost:4000预览）hexo d == hexo deploy #将.deploy目录部署到GitHubhexo g -d #生成加部署hexo g -s #生成加预览 next主题优化next风格选择next有四种风格,在站点配置文件搜索字段Scheme Settings可以看到， # Scheme Settings # --------------------------------------------------------------- # Schemes #scheme: Muse #scheme: Mist #scheme: Pisces scheme: Gemini 我这里用的是四种：Gemini next菜单设置比如可以看到我的主页有首页、留言、分类、归档、标签等菜单，在站点配置文件下搜索menu:,可以看到 menu: home: / || home about: /about/ || user message: /message/ || comment tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat home就是首页;message就是留言…一开始只有首页和归档,其余的需要我们手动创建，在站点根目录下打开命令行,输入hexo new page &quot;about&quot;并在主题配置文件menu:字段处取消对about的注释重新部署我们就可以看到主页有关于这个菜单了，其他的类似，修改D:\hexoblog\source\about\index.md,就可以修改关于界面了about: /about/ || user中的user是指关于菜单附件的图标用的是图标库里面名为user的图标 添加萌妹子动图在根目录下打开命令行输入npm install --save hexo-helper-live2d 修改站点配置文件(注意不是主题配置文件)在末尾加入: live2d: enable: true scriptFrom: local model: scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 display: superSample: 2 width: 150 height: 300 position: right hOffset: 0 vOffset: -20 mobile: show: false react: opacityDefault: 0.5 opacityOnHover: 0. 实现文章首页”分类于”、”阅读次数”等效果效果图如下: 在根目录下打开命令行依次输入以下命令: npm install hexo-wordcount --save npm uninstall hexo-generator-index --save npm install hexo-generator-index-pin-top --save 打开主题配置文件打开相关开关: post_wordcount: item_text: true wordcount: true min2read: true totalcount: true 打开…/themes/next/layout/_macro/post.swig文件把里面的代码用下面的代码替换:点击下载 打开…/themes/next/languages/zh-Hans.yml文件搜索post字段,添加一行comments: 评论数,注意其余的不要改 设置某篇文章置顶前面的流程走完后,只需要在写文章的时候在文章前面加入top: true或者top: 100(100只是个例子，数字越大越靠前),就能实现置顶效果了 常见错误本地预览和同时发布到远程的浏览结果不一致这是由缓存造成的,需要先hexo clean,再hexo g -d部署到远程 markdown高级语法插入连续多行的代码块按一个tab键,然后贴代码，保证每一行代码前都要额外的tab键,同时最前面空一行。比如,我前面插入的连续行代码的实现效果: 设置文字大小和颜色和居中效果hello,world! hello,world! hello,world! hello,world! hello,world!上面的效果需要在markdwon中的代码是这样的: hello,world! &lt;font color=&quot;#FF0000&quot;&gt; hello,world! &lt;/font&gt; &lt;font size=5&gt; hello,world! &lt;/font&gt; &lt;font size=5 color=&quot;#FF0000&quot;&gt;hello,world! &lt;/font&gt; &lt;center&gt;hello,world!&lt;/center&gt; 插入表格效果图: 左对齐标题 右对齐标题 居中对齐标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 markdown代码如下： | 左对齐标题 | 右对齐标题 | 居中对齐标题 | | :------| ------: | :------: | | 短文本 | 中等文本 | 稍微长一点的文本 | | 稍微长一点的文本 | 短文本 | 中等文本 | 感谢赞助所有赞赏过本站的人: 点击查看]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下操作POP3]]></title>
    <url>%2F2018%2F11%2F10%2FWindows%E4%B8%8B%E6%93%8D%E4%BD%9CPOP3%2F</url>
    <content type="text"><![CDATA[Windows10下开启telnet服务在自学《计算机网络-自顶向下方法》这本书中，telnet这个服务命令出现了好多次， 开始在Ubuntu 12.0终端下输入telnet是有正确响应的，但是在windows 10命令行下输入提示找不到该命令，直到今天我才发现该服务在window 1o下是默认关闭的，需要手动打开开启步骤如下 1.用小娜以关键词功能找到开启和关闭Windows功能其实不一定要这样操作，找到开启和关闭Windows功能即可 2.勾选Telnet客户端并确定然后就可以愉快地在windows10玩耍telnet了 Windows下操作POP3pop3是一个邮件访问协议 1.在cmd下输入telnet pop3.163.com 110登录到qq的POP3服务器的110端口2.依次输入user csu_xiaotao和pass xxxxxxxxx登录到自己的邮箱需要注意的是,xxxxxxxxx是邮箱的授权码，不是登录密码 3.然后是一些常见的pop3命令(大小写敏感）1.list列出所有的收到的邮件，特别的`list n’列出第n封邮件其响应格式如下:n m其中n为第n封邮件，m为第n封邮件的字节大小 2.retr n下载第n封邮件其响应格式如下：采用了特殊的编码格式，我们可能看不懂 3.dele n删除第n封邮件4.uidl n返回第n封邮件的唯一标识5.quit退出注意+OK代表操作成功；-ERR代表操作失败]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>pop3</tag>
        <tag>telnet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打卡微信小程序]]></title>
    <url>%2F2018%2F11%2F07%2F%E6%89%93%E5%8D%A1%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[打卡微信小程序。实现功能1、类似论坛，可发帖、评论、回复。 2、打卡可换算积分，一天只能打卡一次，且有今日打卡排行榜实时展示。3、跑步也可换算积分，换算的规则男女有别。实现效果 核心js代码1 var Bmob = require(&quot;../../utils/bmob.js&quot;); var common = require(&quot;../../utils/common.js&quot;); Bmob.initialize(&quot;*************************&quot;, &quot;**************************&quot;); Page({ /** * 页面的初始数据 */ data: { canIUse: wx.canIUse(&apos;button.open-type.getUserInfo&apos;), hiddenmodalput: true, cname: &apos;&apos;, sexx: &apos;&apos;, iname: &apos;&apos;, }, cancel: function(e){ wx.showToast({ title: &apos;务必输入&apos;, icon: &apos;loading&apos; }) }, cn:function(e){ console.log(e.detail.value) this.setData({ cname: e.detail.value }) }, se: function (e) { console.log(e.detail.value) this.setData({ sexx: e.detail.value }) }, ina: function(e){ this.setData({ iname:e.detail.value }) }, confirm: function (e) { var that = this; if (!(that.data.sexx == &apos;男&apos; || that.data.sexx == &apos;女&apos;)){ wx.showToast({ title: &apos;性别输入有误&apos;, }) return; } if(!that.data.cname){ wx.showToast({ title: &apos;姓名班级有误&apos;, }) return; } if(that.data.iname.length&gt;0) { var User = Bmob.Object.extend(&quot;_User&quot;); var query = new Bmob.Query(User); query.equalTo(&apos;nickname&apos;, that.data.iname) query.find({ success: function (results) { if (results.length == 0) { wx.showToast({ title: &apos;无此邀请人&apos;, icon: &apos;loading&apos; }) return; } var user = Bmob.User.logIn(results[0].get(&apos;username&apos;), results[0].get(&apos;userData&apos;).openid, { success: function (users) { var score = users.get(&apos;score&apos;); score = score + 2; users.set(&apos;score&apos;, score); users.save(null, { success: function (user) { wx.showToast({ title: &apos;被邀请成功&apos;, icon: &apos;success&apos; }) }, error: function (error) { console.log(error) } }); } }); } }) } this.setData({ hiddenmodalput: true, }) wx.getStorage({ key: &apos;my_username&apos;, success: function (ress) { if (ress.data) { var my_username = ress.data; wx.getStorage({ key: &apos;user_openid&apos;, success: function (openid) { var openid = openid.data; var user = Bmob.User.logIn(my_username, openid, { success: function (users) { users.set(&apos;nickname&apos;, that.data.cname); users.set(&apos;sex&apos;,that.data.sexx) users.save(null, { success: function (user) { wx.setStorageSync(&apos;my_nick&apos;, that.data.cname); wx.setStorageSync(&quot;sex&quot;, that.data.sexx); }, error: function (error) { console.log(error) } }); } }); }, function(error) { console.log(error); } }) } } }) wx.switchTab({ url: &apos;../punch/punch&apos;, }); }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { }, bindGetUserInfo: function (e) { var that = this; // 查看是否授权 wx.getSetting({ success: function (res) { if (res.authSetting[&apos;scope.userInfo&apos;]) { console.log(&quot;已授权&quot;) // 已经授权，可以直接调用 getUserInfo 获取头像昵称 //调用API从本地缓存中获取数据 try { var value = wx.getStorageSync(&apos;user_openid&apos;) if (value) { console.log(&quot;value不为空&quot;) wx.switchTab({ url: &apos;../punch/punch&apos;, }) } else { console.log(&quot;value为空&quot;) wx.login({ success: function (res) { console.log(&apos;res&apos;, res) if (res.code) { Bmob.User.requestOpenId(res.code, { success: function (userData) { console.log(&apos;uD&apos;,userData) var userInfo = e.detail.userInfo; var nickName = userInfo.nickName; var avatarUrl = userInfo.avatarUrl; Bmob.User.logIn(nickName, userData.openid, { success: function (user) { try { console.log(&apos;sex&apos;+user.get(&apos;sex&apos;)); console.log(&apos;score&apos; + user.get(&apos;score&apos;)); wx.setStorageSync(&quot;newsnum&quot;, user.get(&apos;newsnum&apos;)) wx.setStorageSync(&quot;sex&quot;, user.get(&apos;sex&apos;)); wx.setStorageSync(&quot;score&quot;, user.get(&apos;score&apos;)); wx.setStorageSync(&apos;user_openid&apos;, user.get(&quot;userData&quot;).openid) wx.setStorageSync(&apos;user_id&apos;, user.id); wx.setStorageSync(&apos;my_nick&apos;, user.get(&quot;nickname&quot;)) wx.setStorageSync(&apos;my_username&apos;, user.get(&quot;username&quot;)) wx.setStorageSync(&apos;my_avatar&apos;, user.get(&quot;userPic&quot;)) } catch (e) { } console.log(&quot;登录成功y&quot;); }, error: function (user, error) { console.log(&apos;test&apos;,error) if (error.code == &quot;101&quot;) { that.setData({ hiddenmodalput: false, }) var user = new Bmob.User();//开始注册用户 user.set(&quot;username&quot;, nickName); user.set(&quot;password&quot;, userData.openid);//因为密码必须提供，但是微信直接登录小程序是没有密码的，所以用openId作为唯一密码 user.set(&quot;sex&quot;,&quot;男&quot;); user.set(&quot;score&quot;,0); user.set(&apos;newsnum&apos;,0); user.set(&quot;nickname&quot;, nickName); user.set(&quot;userPic&quot;, avatarUrl); user.set(&quot;userData&quot;, userData); user.signUp(null, { success: function (results) { try {//将返回的3rd_session储存到缓存 wx.setStorageSync(&apos;user_openid&apos;, results.get(&quot;userData&quot;).openid) wx.setStorageSync(&apos;user_id&apos;, results.id); wx.setStorageSync(&apos;my_username&apos;, results.get(&quot;username&quot;)); wx.setStorageSync(&quot;newsnum&quot;, results.get(&apos;newsnum&apos;)); wx.setStorageSync(&quot;score&quot;, 0); wx.setStorageSync(&quot;sex&quot;, &quot;男&quot;); wx.setStorageSync(&apos;my_nick&apos;, results.get(&quot;nickname&quot;)); wx.setStorageSync(&apos;my_avatar&apos;, results.get(&quot;userPic&quot;) ) console.log(&quot;注册成功!&quot;); } catch (e) { } }, error: function (userData, error) { console.log(error) } }); } } }); }, }); } else { console.log(&apos;获取用户登录态失败！&apos; + res.errMsg) } }, }); } } catch (e) { console.log(&quot;登陆失败&quot;) } wx.checkSession({ success: function () { }, fail: function () { //登录态过期 wx.login() } }) } } }) }, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () { }, /** * 生命周期函数--监听页面显示 */ onShow: function () { }, /** * 生命周期函数--监听页面隐藏 */ onHide: function () { }, /** * 生命周期函数--监听页面卸载 */ onUnload: function () { }, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () { wx.stopPullDownRefresh() }, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () { }, /** * 用户点击右上角分享 */ onShareAppMessage: function () { } }) ``` ` github地址,欢迎star、fork!!!]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于opencv人脸识别的员工考勤系统]]></title>
    <url>%2F2018%2F09%2F25%2F%E5%9F%BA%E4%BA%8Eopencv%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%9A%84%E5%91%98%E5%B7%A5%E8%80%83%E5%8B%A4%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[WorkAttendanceSystem一个基于opencv人脸识别的员工考勤系统，作者某双一流A类大学里的二流学生，写于2018/09/，python课设期间。 工程简介项目结构是V1.0版本的，V2.0的介绍请看文末更新版块项目结构mainui.py是主界面，调用face_img_register.py和face_recognize_punchcard.py其中face_img_register.py是录入人脸信息，face_recognize_punchcard.py是刷脸考勤face_feature_storage.py属于鸡肋文件，没什么用，舍不得删，毕竟有点参考价值。face_recognize_punchcard_lib.py和face_recognize_punchcard.py本质上差不多，但是前者是给face_img_register.py专有的依赖。防止录入两个同样的人脸建不同数据库的风险。 运行效果1. 主界面 2. 人脸录入 3. 刷脸考勤 其余的就不多做展示了，有什么问题欢迎2391527690@qq.com联系 更新V1.0版本2018/9/23更新mainui.py–&gt;myapp.pyface_recognize_punchcard_lib.py等鸡肋文件放到useless文件夹里运行效率显著提高 2018/9/25更新解决同步性问题，新录入的人脸能立即被识别代码的运行速度少许下降 V2.0版本1. 全新设计的UI,更人性化的操作 2. 数据更加安全，用户不可见人脸数据和签到日志全部保存在inspurer.db数据库文件里，更加安全；而且对人脸数据进行了压缩，更加小巧。 3. 注意事项 打开摄像头时请左右晃动一下人脸，确保人脸识别开始。 人脸识别时做了拒绝处理，多张人脸时，只取距离屏幕最近的人脸。 新建录入时会自动录入十张人脸照片，也可手动点击完成录入立即完成，之后就会计算人脸数据并存储到数据库中，左边的信息栏会有相应的信息打印。 开始签到后，如不点击结束签到,就会一直对屏幕前的人脸进行签到，签到状态分三种,未识别的人脸，签到成功，签到成功但是迟到了(9.00后签到),重复签到(此时签到日志不会写入到数据库。 为确保程序稳定性，每一个菜单里的按钮尽量成对操作。 Thanks for your attention;can you fork it if helping you? Thanks again！CopyRight 2391527690@qq.com;send me for allowance if you want to transmit it 源代码地址github]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>人脸识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之单链表]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[从今天起开始数据结构系列的分享，今天分享的是单链表。单链表大概是大概是每个数据结构初学者的必经之路，下面结合一个小小的工程来深入学习单链表的使用–简易客户管理系统。ps：如果还不清楚单链表是什么的小伙伴自行百度，在此不在赘述 #项目结构如图所示大致了解了项目架构后，下面开始从零编写代码注：增、删、改这三个部分同时包含了将变动后的信息写入到文件中的操作 #代码编写 ##项目基础代码俗话说得好，“万丈高楼平地起”，先来编写项目的预定义代码部分，主要是头文件包含、结构体定义、全局变量定义等 ###头文件包含#include&lt;stdio.h&gt; //C程序基础库#include&lt;stdlib.h&gt; //包含函数exit()#include&lt;string.h&gt; //包含函数strcmp() ###结构体定义 typedef struct item{ char name[20]; //保存客户姓名 char gender[20]; //保存客户性别 int age; //保存客户年龄 char tel[20]; //保存客户号码} guest;结构体定义不要多说了哈，这里typedef...guest是给结构体item起别名的意思，也就是struct item在这个源文件里面等价于guest typedef struct node { guest data; //数据域 struct node next; //指针域} link;这里是给指向结构体node的指针起别名 ###全局变量定义link T;//头指针这个头指针T是整个系统的索引，六个模块共有一个，虽然有尽量少定义全局变量的原则，但这里的全局变量T可以避免各个函数间复杂的参数传递问题，牺牲了空间，换取了运行时间的减少；同时要注意我在后面对T的初始化代码 //初始化头指针T=(link)malloc(sizeof(struct node));T-&gt;next = NULL;这里并没有给T安排数据域，T不是第一个存储客户信息的节点指针，T-&gt;next才是，初始化头指针时还没有存储客户信息的结点加入，所以T-&gt;next=NULL;,这是一个编程者应该养成的好习惯；为什么不给T安排数据域呢，这里主要考虑到后面的删除模块的编写，我们知道，删除一个结点，要先找到这个结点的前驱指针p和后驱指针q，然后p-&gt;next = q-&gt;next；,如果给T安排数据域的话，T的前驱是什么呢？就算不用上面我说的那套删除逻辑，用if...else...语句和另外一套逻辑完成对T的删除，代码明显复杂些。 ##项目核心代码 ###一、加载文件代码如下 void init() { link p,s; FILE *fp; int i = 0; s = p=(link)malloc(sizeof(struct node)); p-&gt;next = NULL; if((fp=fopen(“1.txt”,”r”))==NULL) { printf(“load error!”); exit(1); } while(!feof(fp)) { fscanf(fp,”%s\t%s\t%d\t%s\t\n”,p-&gt;data.name,p-&gt;data.gender,&amp;p-&gt;data.age,p-&gt;data.tel); i++; if(i!=1) { s-&gt;next = p; s=p; } else{ T-&gt;next = p; } p=(link)malloc(sizeof(struct node)); p-&gt;next = NULL; } printf(“总人数i=====%d\n”,i); if(fclose(fp)) { printf(“Can’t close the file!\n”); exit(1); }}介绍下代码逻辑，新开辟内存空间，并使s、p指向它，打开文件，如果文件指针没有到文件尾，将从文件读取到的一个客户信息赋给p的数据域，如果是读取第一个客户信息，将p指向的结点连在头指针T后面，否则，将p连在s后面，因为这个时候s是p的前驱指针，连接成功后将p赋值给s，p又指向一个新开辟的结点…图示： ###二、增加客户代码如下： //添加void create() { link p,s; FILE *fp; int yn; s=T; while(s-&gt;next!=NULL) { s=s-&gt;next; } do { p=(link)malloc(sizeof(struct node)); printf(“请输入客户姓名：\n”); scanf(“%s”,p-&gt;data.name); printf(“请输入客户性别：\n”); scanf(“%s”,p-&gt;data.gender); printf(“请输入客户年龄：\n”); scanf(“%d”,&amp;p-&gt;data.age); printf(“请输入客户联系方式：\n”); scanf(“%s”,p-&gt;data.tel); p-&gt;next=NULL; s-&gt;next=p; s=p; if((fp=fopen(“1.txt”,”at”))==NULL) { printf(“write error!\n”); exit(0); } printf(“写了一次\n”); fprintf(fp,”%s\t%s\t%d\t%s\n”,p-&gt;data.name,p-&gt;data.gender,p-&gt;data.age,p-&gt;data.tel); if(fclose(fp)) { printf(“can’t close the file!\n”); exit(0); } printf(“添加成功!\n”); printf(“是否继续添加请输入0或1:”); scanf(“%d”,&amp;yn); } while(yn);}代码逻辑很简单，新增结点，并连在尾节点后面，同时写入文件，如果前一片代码看懂了，这不是什么大问题… ###三、删除客户代码如下 //删除int del() { link p,q; FILE *fp; char mod[25]; printf(“请输入需要删除的客户名称:\n”); scanf(“%s”,mod); p=T; while(p-&gt;next!=NULL&amp;&amp;strcmp(p-&gt;next-&gt;data.name,mod)!=0) p=p-&gt;next; if(p-&gt;next==NULL) { printf(“并无此人！\n”); return 0; } q = p; p = p-&gt;next; q-&gt;next = p-&gt;next; delete(p); printf(“删除成功！\n”); if((fp=fopen(“1.txt”,”wt”))==NULL) { printf(“error!\n”); exit(0); } p=T-&gt;next; while(p!=NULL) { printf(“%s”,p-&gt;data.name); fprintf(fp,”%s\t%s\t%d\t%s\t\n”,p-&gt;data.name,p-&gt;data.gender,p-&gt;data.age,p-&gt;data.tel); p = p-&gt;next; } if(fclose(fp)) { printf(“can’t close the file!\n”); exit(1); }}模块三、四、五、六道理类似，不再赘述附上代码地址：github 欢迎star如有疑问，欢迎进群讨论：如链接失效，扫二维码：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门第二天]]></title>
    <url>%2F2018%2F08%2F17%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[前言许久未更新了，今天七夕，为了逃避现实，重启博客。本博客主要记录一些前端学习中的入门级问题。 正文Q1：HTML标签、元素、属性都是什么概念？HTML标签：HTML标签标记了HTML文档和HTML元素，HTML标签由开始标签和结束标签组成.开始标签为尖括号包围的元素名,结束标签为尖括号包围的斜杠和元素名。例如:&lt;h2&gt; My First Heading&lt;/h2&gt; HTML元素：HTML文档是由html元素定义的.HTML的元素是指从开始标签到结束标签的所有代码..例如:&lt;p&gt;我是一个段落&lt;/p&gt;表示一个html元素.可以看出,html元素主要包括html标签和纯文本.标签定义网页显示的格式,文本表示网页的内容.故此,网页 = html文档,而html文档则是由html元素定义的. HTML属性：HTML属性为HTML元素提供附件信息,例如在超链接标签&lt;a href = “https://inspurer.github.io&gt;月小水长的个人博客&lt;/a&gt;使用了href属性来指定超链接的地址.属性总是以名称/值的形式出现,例如:name = “value”属性总是在开始标签中定义. Q2：meta标签都用来做什么的？ 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 标签位于文档的头部，不包含任何内容。 标签的属性定义了与文档相关联的名称/值对。 Q3： Web语义化是什么，是为了解决什么问题？简言之，web语义化的目的是提高计算机和人对web代码的可读性。 网上的解释很多，个人总结分三个阶段比较容易理解。1、原始的一些有实际含义的标签定义。浏览器和W3C组织推出的如h1~h6、thead、ul、ol的HTML标签用于在Web页面中组织对应的内容，如网页标题、表头、无序、有序列表，以达到更方便的协作及传播互联网内容的目的。搜索引擎很好的利用了这些语义化标签抓取内容，又鉴于搜索引擎的巨大流量推荐，Web前端不得不考虑SEO，从而两者实现有益的循环，共同推进着语义化标签的使用。 2、前端开发人员自定义的标签。但Web的发展超乎想象，起初定义的HTML语义化标签，不足以实现对Web页面各个部分的功能或位置描述，所以Web前端人员利用HTML标签的id和class属性，进一步对HTML标签进行描述，如对页脚HTML标签添加如id=”footer“或者class=”footer”的属性（值），以“无声”的方式 在不同的前端程序员或者前后端程序员间实现交流。 3、在第二步的推动下结合新技术出现的一些标签。W3C组织意识到了之前HTML版本的不足，推出的HTML5进一步推进了Web语义化发展，采用了诸如footer、section等语义化标签，弥补了采用id=”footer”或者class=”footer”形式的不足，以更好的推动Web的发展。正所谓：世上本没有路，走的人多了，也便成了路。 Q4: 表单标签都有哪些，对应着什么功能，都有哪些属性?还是W3School的这篇教程经典：HTML表单标签之input Q5: ol, ul, li, dl, dd, dt等这些标签都适合用在什么地方?举个例子.1.无序列表无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。无序列表始于 &lt;ul&gt;标签。每个列表项始于 &lt;li&gt;。 2.有序列表同样，有序列表也是一列项目，列表项目使用数字进行标记。有序列表始于 &lt;ol&gt;标签。每个列表项始于&lt;li&gt; 标签。` Coffee Milk `浏览器显示如下 3.定义列表自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以 &lt;dl&gt;标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以&lt;dd&gt; 开始。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门杂记]]></title>
    <url>%2F2018%2F06%2F12%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言从今天开始在本教程上纪录当日学到的知识点，不追求百科全书式的纪录只记录那些我比较陌生的或者觉得比较容易混淆的 笔记正文 先来纪录一个坑，用notepad++写出第一个html文档时，代码如下保存为html文件，在火狐浏览器打开，发现文档的内容这几个字是乱码不是utf-8/cp36的问题，而是必须这个html文档必须要BOM头 太累了，后续更新…2018/6/13深夜]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门第一天]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[前言前不久在网上看到一篇Hexo建站的教程，顺手给自己建了个个人博客 有还算扎实的c++/java/python/andorid基础，整个建站过程还算顺利从此沉迷web编程,但是我感觉用现成的框架,总有点那啥受制于人的感觉打算好好学一下前端，由于在实验室跟着老师做项目一直没有时间但是万万没想到，心心念念的前端，开始正式开始系统学习居然是在忙到炸的期末考试周在此要先pick一下百度前端技术学院,可以说是我的前端入门导师了哈哈哈，不bb了，正式开始。 首先我们要知道访问网站的具体过程比如，输入http://www.zhihu.com/question/22689579访问过程如下图所示浏览器和服务器交流，服务器和数据库交流（有时候数据库就在服务器那台机子上）浏览器给服务器发一个请求，服务器不是一看就知道怎么响应的。首先这些请求和响应要有一个通用的写法，也就是要有一个协议，常用的是HTTP协议。像最前面的图，服务器的响应写了一个状态码200 OK,是HTTP协议里约定俗成的一个东西，服务器写200 OK在响应里，表示“你请求的这个东西我有”，如果是404 Not Found，就是“你请求的这个东西我这里没有”。HTTP响应里还包括很多东西，比如Content-type表示服务器发过来的文件类型是什么（文本？动画？图片？音频？）形象化Http响应，大概这样： 然后我们来了解前端三剑客 html 接上图，服务器返回html（就是上图HTTP响应的body里的内容)文件 后,电脑拿到html后，浏览器就会对它进行解析渲染，html是一种文本标记语言，举个栗子： css 浏览器拿到这些代码之后，分析一下给你渲染好页面显示出来，但是如果没有用css，效果是这样的，按照浏览器默认的样式显示出列表、图片、超链接、输入框、按钮等等：是不是觉得默认样式有点看瞎狗眼呢……所以很多时候我们需要自定义样式，现行通用的规定样式的语言是CSS，我们可以用它写一些定义样式的代码，在 html 文件里用一个标签把这些规定样式的CSS代码与表达内容语义的HTML代码关联起来，然后你就能看到一个符合人类正常审美的页面了:插一句：CSS 代码的格式基本是属性 : 值 javascipt(js)有了表示内容和语义的 HTML，规定样式的 CSS，得到的是一个静态的页面，没什么动画（其实用 CSS 还是可以有一些动画的,不过这个跑题了),按 F5 才会刷新数据，于是我们有了 Javascript(js)来给页面添加一些动态的效果浏览器都会帮你实现一些 JS 可以用的工具（函数，对象什么的），你只要写一些js的代码，保存在xxx.js 里，在html文件中用 &lt;script&gt;关联进来就可以用了 在前端三剑客bb了怎么多，可以用一句很形象的话来归纳之：前台三剑客，html是名词，css是形容词，javascript是动词。三个互相配合才是一句子就问形不形象 立个Flag考虑到三周的期末周，就立一个这样的flag吧：暑假每天至少学习前端两个小时，争取下学期开始学完！ 致谢最后实名pick一下小姐姐张秋怡,感谢她的精彩回答我只是个搬运工只不过经过自己的理解稍作了修改2018/6/12 00:31初稿欢迎评论啊]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[”月小水长“和“inspurer”的由来]]></title>
    <url>%2F2018%2F06%2F07%2F%E6%9C%88%E5%B0%8F%E6%B0%B4%E9%95%BF%E7%9A%84%E7%94%B1%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[非凭空臆想,其有典故；宋苏轼在后赤壁赋有云：山高月小，水落石出曾日月之几何，而江山不可复识矣在此我引申出月小水长句，一为不怕贻笑大方而附庸风雅，二为吾全名肖涛之字析，月小为肖，水即三点水，长寿为涛，还算是能够自圆其说。至于inspurer,大一的时候了解到一家很厉害的中国企业inspur浪潮想不到中国除了华为还有在高新技术领域耕耘了这么深的企业，遂起名inspurer，寓意弄潮儿，想成为那种站在技术潮头的人儿呐~]]></content>
      <categories>
        <category>生活志</category>
      </categories>
  </entry>
</search>
